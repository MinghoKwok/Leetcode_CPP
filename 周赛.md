

# 语法记录



* char c = 0   等价于   char c = '\0'。 （ASCII 码 0 对应 '\0'）

* auto是c++程序设计语言的关键字。用于两种情况

  （1）声明变量时根据初始化表达式自动推断该变量的类型

  （2）声明函数时函数返回值的占位符

* ```c++
  int a, b;
  double c = (double) (a / b);	//无法取小数
  c = (double) a / (double) b;	//可以取小数
  ```

* 



# Weekly Contest 289	04/16/22

## 2243. Calculate Digit Sum of a String

[My Submissions](https://leetcode.com/contest/weekly-contest-289/problems/calculate-digit-sum-of-a-string/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-289/)

- **User Accepted:**7882
- **User Tried:**8377
- **Total Accepted:**8055
- **Total Submissions:**13099
- **Difficulty:****Easy**

You are given a string `s` consisting of digits and an integer `k`.

A **round** can be completed if the length of `s` is greater than `k`. In one round, do the following:

1. **Divide** `s` into **consecutive groups** of size `k` such that the first `k` characters are in the first group, the next `k` characters are in the second group, and so on. **Note** that the size of the last group can be smaller than `k`.
2. **Replace** each group of `s` with a string representing the sum of all its digits. For example, `"346"` is replaced with `"13"` because `3 + 4 + 6 = 13`.
3. **Merge** consecutive groups together to form a new string. If the length of the string is greater than `k`, repeat from step `1`.

Return `s` *after all rounds have been completed*.

 

**Example 1:**

```
Input: s = "11111222223", k = 3
Output: "135"
Explanation: 
- For the first round, we divide s into groups of size 3: "111", "112", "222", and "23".
  Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. 
  So, s becomes "3" + "4" + "6" + "5" = "3465" after the first round.
- For the second round, we divide s into "346" and "5".
  Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. 
  So, s becomes "13" + "5" = "135" after second round. 
Now, s.length <= k, so we return "135" as the answer.
```

**Example 2:**

```
Input: s = "00000000", k = 3
Output: "000"
Explanation: 
We divide s into "000", "000", and "00".
Then we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. 
s becomes "0" + "0" + "0" = "000", whose length is equal to k, so we return "000".
```

 

**Constraints:**

- `1 <= s.length <= 100`
- `2 <= k <= 100`
- `s` consists of digits only.



## 2244. Minimum Rounds to Complete All Tasks

[My Submissions](https://leetcode.com/contest/weekly-contest-289/problems/minimum-rounds-to-complete-all-tasks/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-289/)

- **User Accepted:**6974
- **User Tried:**8059
- **Total Accepted:**7146
- **Total Submissions:**15225
- **Difficulty:****Medium**

You are given a **0-indexed** integer array `tasks`, where `tasks[i]` represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the **same difficulty level**.

Return *the **minimum** rounds required to complete all the tasks, or* `-1` *if it is not possible to complete all the tasks.*

 

**Example 1:**

```
Input: tasks = [2,2,3,3,2,4,4,4,4,4]
Output: 4
Explanation: To complete all the tasks, a possible plan is:
- In the first round, you complete 3 tasks of difficulty level 2. 
- In the second round, you complete 2 tasks of difficulty level 3. 
- In the third round, you complete 3 tasks of difficulty level 4. 
- In the fourth round, you complete 2 tasks of difficulty level 4.  
It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.
```

**Example 2:**

```
Input: tasks = [2,3,3]
Output: -1
Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.
```

 

**Constraints:**

- `1 <= tasks.length <= 105`
- `1 <= tasks[i] <= 109`



## 2245. Maximum Trailing Zeros in a Cornered Path

- **Difficulty:** **Medium**

You are given a 2D integer array `grid` of size `m x n`, where each cell contains a positive integer.

A **cornered path** is defined as a set of adjacent cells with **at most** one turn. More specifically, the path should exclusively move either **horizontally** or **vertically** up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the **alternate** direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.

The **product** of a path is defined as the product of all the values in the path.

Return *the **maximum** number of **trailing zeros** in the product of a cornered path found in* `grid`.

Note:

- **Horizontal** movement means moving in either the left or right direction.
- **Vertical** movement means moving in either the up or down direction.

 

**Example 1:**

![img](images/ex1new2.jpg)

```
Input: grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]
Output: 3
Explanation: The grid on the left shows a valid cornered path.
It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.
It can be shown that this is the maximum trailing zeros in the product of a cornered path.

The grid in the middle is not a cornered path as it has more than one turn.
The grid on the right is not a cornered path as it requires a return to a previously visited cell.
```

**Example 2:**

![img](images/ex2-2130211.jpg)

```
Input: grid = [[4,3,2],[7,6,1],[8,8,8]]
Output: 0
Explanation: The grid is shown in the figure above.
There are no cornered paths in the grid that result in a product with a trailing zero.
```

 

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 105`
- `1 <= m * n <= 105`
- `1 <= grid[i][j] <= 1000`





# Weekly Contest 290

### 2248. Intersection of Multiple Arrays

[My Submissions](https://leetcode.com/contest/weekly-contest-290/problems/intersection-of-multiple-arrays/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-290/)

- **User Accepted:**8227
- **User Tried:**8525
- **Total Accepted:**8430
- **Total Submissions:**12757
- **Difficulty:****Easy**

Given a 2D integer array `nums` where `nums[i]` is a non-empty array of **distinct** positive integers, return *the list of integers that are present in **each array** of* `nums` *sorted in **ascending order***.

 

**Example 1:**

```
Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
Output: [3,4]
Explanation: 
The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].
```

**Example 2:**

```
Input: nums = [[1,2,3],[4,5,6]]
Output: []
Explanation: 
There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].
```

 

**Constraints:**

- `1 <= nums.length <= 1000`
- `1 <= sum(nums[i].length) <= 1000`
- `1 <= nums[i][j] <= 1000`
- All the values of `nums[i]` are **unique**.

[Discuss](https://leetcode.com/problems/intersection-of-multiple-arrays/discuss)



### 2249. Count Lattice Points Inside a Circle

[My Submissions](https://leetcode.com/contest/weekly-contest-290/problems/count-lattice-points-inside-a-circle/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-290/)

- **User Accepted:**4253
- **User Tried:**5742
- **Total Accepted:**4842
- **Total Submissions:**11065
- **Difficulty:****Medium**

Given a 2D integer array `circles` where `circles[i] = [xi, yi, ri]` represents the center `(xi, yi)` and radius `ri` of the `ith` circle drawn on a grid, return *the **number of lattice points*** *that are present inside **at least one** circle*.

**Note:**

- A **lattice point** is a point with integer coordinates.
- Points that lie **on the circumference of a circle** are also considered to be inside it.

 

**Example 1:**

![img](images/exa-11.png)

```
Input: circles = [[2,2,1]]
Output: 5
Explanation:
The figure above shows the given circle.
The lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.
Other points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.
Hence, the number of lattice points present inside at least one circle is 5.
```

**Example 2:**

![img](images/exa-22.png)

```
Input: circles = [[2,2,2],[3,4,1]]
Output: 16
Explanation:
The figure above shows the given circles.
There are exactly 16 lattice points which are present inside at least one circle. 
Some of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).
```

 

**Constraints:**

- `1 <= circles.length <= 200`
- `circles[i].length == 3`
- `1 <= xi, yi <= 100`
- `1 <= ri <= min(xi, yi)`



### My C++ solution

```c++
class Solution {
public:
    int countLatticePoints(vector<vector<int>>& circles) {
        set<pair<int, int>> points;
        
        for (int i = 0; i < circles.size(); i++) {
            int x0 = circles[i][0];
            int y0 = circles[i][1];
            int r = circles[i][2];
            
            for (int x = x0 - r; x <= x0 + r; x++) {
                for (int y = y0 - r; y <= y0 + r; y++) {
                    pair<int, int> point = {x, y}; 
                    if ((x - x0) * (x - x0) + (y - y0) * (y - y0) <= r * r)
                        points.insert(point);
                }
            }
        }
        
        return points.size();
    }
};
```





# Weekly Contest 291

## 2259. Remove Digit From Number to Maximize Result

[My Submissions](https://leetcode.com/contest/weekly-contest-291/problems/remove-digit-from-number-to-maximize-result/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-291/)

- **User Accepted:**7271
- **User Tried:**8673
- **Total Accepted:**7459
- **Total Submissions:**18729
- **Difficulty:****Easy**

You are given a string `number` representing a **positive integer** and a character `digit`.

Return *the resulting string after removing **exactly one occurrence** of* `digit` *from* `number` *such that the value of the resulting string in **decimal** form is **maximized***. The test cases are generated such that `digit` occurs at least once in `number`.

 

**Example 1:**

```
Input: number = "123", digit = "3"
Output: "12"
Explanation: There is only one '3' in "123". After removing '3', the result is "12".
```

**Example 2:**

```
Input: number = "1231", digit = "1"
Output: "231"
Explanation: We can remove the first '1' to get "231" or remove the second '1' to get "123".
Since 231 > 123, we return "231".
```

**Example 3:**

```
Input: number = "551", digit = "5"
Output: "51"
Explanation: We can remove either the first or second '5' from "551".
Both result in the string "51".
```

 

**Constraints:**

- `2 <= number.length <= 100`
- `number` consists of digits from `'1'` to `'9'`.
- `digit` is a digit from `'1'` to `'9'`.
- `digit` occurs at least once in `number`.



### My C++ solution

```c++
class Solution {
public:
    string removeDigit(string number, char digit) {
        string max_val = "";
        
        for (int i = 0; i < number.size(); i++) {
            if (number[i] == digit)
                max_val = max(max_val, afterRemove(number, i));
        }
            
        return max_val;
        
    }
    
    string afterRemove(string number, int index) {
        string str1 = number.substr(0, index);
        string str2 = number.substr(index + 1);
        return str1.append(str2);
    }
};
```







## 2260（Map）. Minimum Consecutive Cards to Pick Up

[My Submissions](https://leetcode.com/contest/weekly-contest-291/problems/minimum-consecutive-cards-to-pick-up/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-291/)

- **User Accepted:**6733
- **User Tried:**7748
- **Total Accepted:**6858
- **Total Submissions:**14005
- **Difficulty:****Medium**

You are given an integer array `cards` where `cards[i]` represents the **value** of the `ith` card. A pair of cards are **matching** if the cards have the **same** value.

Return *the **minimum** number of **consecutive** cards you have to pick up to have a pair of **matching** cards among the picked cards.* If it is impossible to have matching cards, return `-1`.

 

**Example 1:**

```
Input: cards = [3,4,2,3,4,7]
Output: 4
Explanation: We can pick up the cards [3,4,2,3] which contain a matching pair of cards with value 3. Note that picking up the cards [4,2,3,4] is also optimal.
```

**Example 2:**

```
Input: cards = [1,0,5,3]
Output: -1
Explanation: There is no way to pick up a set of consecutive cards that contain a pair of matching cards.
```

 

**Constraints:**

- `1 <= cards.length <= 105`
- `0 <= cards[i] <= 106`



```c++
class Solution {
public:
    int minimumCardPickup(vector<int>& cards) {
        int res = 100001;
        map<int, int> val_index;
        for (int i = 0; i < cards.size(); i++) {
            int cur_val = cards[i];
            auto iter = val_index.find(cur_val);    //查找之前是否出现过相同的数值
            if (iter != val_index.end()) {         //之前出现过相同的数值
                res = min(res, i - iter->second + 1);
                val_index.erase(iter);              //删除前面的，只保留最后一个
            }
            
            val_index.insert(pair<int, int>(cur_val, i));
        }
        
        return res == 100001 ? -1 : res;
    }
};
```



# Weekly Contest 292	05/07/22



## 2264. Largest 3-Same-Digit Number in String

[My Submissions](https://leetcode.com/contest/weekly-contest-292/problems/largest-3-same-digit-number-in-string/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-292/)

- **Difficulty:** **Easy**

You are given a string `num` representing a large integer. An integer is **good** if it meets the following conditions:

- It is a **substring** of `num` with length `3`.
- It consists of only one unique digit.

Return *the **maximum good** integer as a **string** or an empty string* `""` *if no such integer exists*.

Note:

- A **substring** is a contiguous sequence of characters within a string.
- There may be **leading zeroes** in `num` or a good integer.

 

**Example 1:**

```
Input: num = "6777133339"
Output: "777"
Explanation: There are two distinct good integers: "777" and "333".
"777" is the largest, so we return "777".
```

**Example 2:**

```
Input: num = "2300019"
Output: "000"
Explanation: "000" is the only good integer.
```

**Example 3:**

```
Input: num = "42352338"
Output: ""
Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.
```

 

**Constraints:**

- `3 <= num.length <= 1000`
- `num` only consists of digits.



### My Java Solution

```java
class Solution {
    public String largestGoodInteger(String num) {
        int max_good = -1;
        int cur_digit = num.charAt(0) - '0';
        int cur_count = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int now_digit = num.charAt(i) - '0';
            if (cur_digit != now_digit) {
                cur_digit = now_digit;
                cur_count = 1;
            } else {
                cur_count++;
                if (cur_count == 3) {
                    if (cur_digit > max_good) {
                        max_good = cur_digit;
                    }
                }
            }
        }
        
        if (max_good == -1)
            return "";
        else {
            String res_digit = max_good + "";
            return res_digit + res_digit + res_digit;
        }
    }
}
```





### C++ Solution

```c++
class Solution {
public:
    string largestGoodInteger(string num) {
        char res = 0;
        for (int i = 2; i < num.size(); i++) {
            if (num[i] == num[i - 1] && num[i - 1] == num[i - 2])
                res = max(res, num[i]);
        }
        
        return res == 0 ? "" : string(3, res);
    }
};
```







## 2265. Count Nodes Equal to Average of Subtree

[My Submissions](https://leetcode.com/contest/weekly-contest-292/problems/count-nodes-equal-to-average-of-subtree/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-292/)

- **Difficulty:** **Medium**

Given the `root` of a binary tree, return *the number of nodes where the value of the node is equal to the **average** of the values in its **subtree***.

**Note:**

- The **average** of `n` elements is the **sum** of the `n` elements divided by `n` and **rounded down** to the nearest integer.
- A **subtree** of `root` is a tree consisting of `root` and all of its descendants.

 

**Example 1:**

![img](images/image-20220315203925-1.png)

```
Input: root = [4,8,5,0,1,null,6]
Output: 5
Explanation: 
For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.
For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.
For the node with value 0: The average of its subtree is 0 / 1 = 0.
For the node with value 1: The average of its subtree is 1 / 1 = 1.
For the node with value 6: The average of its subtree is 6 / 1 = 6.
```

**Example 2:**

![img](images/image-20220326133920-1.png)

```
Input: root = [1]
Output: 1
Explanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `0 <= Node.val <= 1000`

[Discuss](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/discuss)

### My java solution

```java

public class MyTreeNode {
    int sum;
    int count;
    MyTreeNode left;
    MyTreeNode right;
    MyTreeNode() {}
    MyTreeNode(int sum, int count) {
        this.sum = sum;
        this.count = count;
    }
    MyTreeNode(MyTreeNode left, MyTreeNode right) {
        this.left = left;
        this.right = right;
    }
}

class Solution {
    int res = 0;
    MyTreeNode my_root = new MyTreeNode();
    
    public int averageOfSubtree(TreeNode root) {
        initialMyTree(my_root, root);
        
        constructMyTree(my_root, root);
        
        return count(my_root, root);
    }
    
    public void initialMyTree(MyTreeNode myroot, TreeNode root) {
        if (root.left != null) {
            myroot.left = new MyTreeNode();
            initialMyTree(myroot.left, root.left);
        }
        
        if (root.right != null) {
            myroot.right = new MyTreeNode();
            initialMyTree(myroot.right, root.right);
        }
    }
    
    public void constructMyTree(MyTreeNode myroot, TreeNode root) {
        if (root.left == null && root.right == null) {
            myroot.sum = root.val;
            myroot.count = 1;
        } else {
            myroot.sum = root.val;
            myroot.count = 1;
            if (root.left != null) {
                constructMyTree(myroot.left, root.left);
                myroot.sum += myroot.left.sum;
                myroot.count += myroot.left.count;
            }
            
            if (root.right != null) {
                constructMyTree(myroot.right, root.right);
                myroot.sum += myroot.right.sum;
                myroot.count += myroot.right.count;
            }
        }
        
    }
    
    public int count(MyTreeNode myroot, TreeNode root) {
        int res = 0;
        if (myroot.sum / myroot.count == root.val) {
            res++;
            //System.out.println(root.val);
        }
            
        
        if (root.left != null)
            res += count(myroot.left, root.left);
        if (root.right != null)
            res += count(myroot.right, root.right);
        
        return res;
    }
}
```





### C++ Solution

```c++
class Solution {
public:
    int res = 0;
    
    pair<int, int> counting(TreeNode* root) { // {sum, count}
        if (root == NULL)
            return {0, 0};
        
        int cur_val = root->val;
        
        pair<int, int> left = counting(root->left);
        pair<int, int> right = counting(root->right);
        
        int sum = left.first + right.first + cur_val;
        int count = left.second + right.second + 1;
        
        if (sum / count == cur_val)
            res++;
        
        return {sum, count};
    }
    
    int averageOfSubtree(TreeNode* root) {
        counting(root);
        
        return res;
    }
};
```





# Weekly Contest 293

## 2273. Find Resultant Array After Removing Anagrams

[My Submissions](https://leetcode.com/contest/weekly-contest-293/problems/find-resultant-array-after-removing-anagrams/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-293/)

- **User Accepted:**8915
- **User Tried:**9816
- **Total Accepted:**9586
- **Total Submissions:**18929
- **Difficulty:****Easy**

You are given a **0-indexed** string array `words`, where `words[i]` consists of lowercase English letters.

In one operation, select any index `i` such that `0 < i < words.length` and `words[i - 1]` and `words[i]` are **anagrams**, and **delete** `words[i]` from `words`. Keep performing this operation as long as you can select an index that satisfies the conditions.

Return `words` *after performing all operations*. It can be shown that selecting the indices for each operation in **any** arbitrary order will lead to the same result.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, `"dacb"` is an anagram of `"abdc"`.

 

**Example 1:**

```
Input: words = ["abba","baba","bbaa","cd","cd"]
Output: ["abba","cd"]
Explanation:
One of the ways we can obtain the resultant array is by using the following operations:
- Since words[2] = "bbaa" and words[1] = "baba" are anagrams, we choose index 2 and delete words[2].
  Now words = ["abba","baba","cd","cd"].
- Since words[1] = "baba" and words[0] = "abba" are anagrams, we choose index 1 and delete words[1].
  Now words = ["abba","cd","cd"].
- Since words[2] = "cd" and words[1] = "cd" are anagrams, we choose index 2 and delete words[2].
  Now words = ["abba","cd"].
We can no longer perform any operations, so ["abba","cd"] is the final answer.
```

**Example 2:**

```
Input: words = ["a","b","c","d","e"]
Output: ["a","b","c","d","e"]
Explanation:
No two adjacent strings in words are anagrams of each other, so no operations are performed.
```

 

**Constraints:**

- `1 <= words.length <= 100`
- `1 <= words[i].length <= 10`
- `words[i]` consists of lowercase English letters.

[Discuss](https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/discuss)

### My C++ solution

```c++
class Solution {
public:
    vector<string> removeAnagrams(vector<string>& words) {
        vector<string> copy(words);
        vector<string> res;
        res.push_back(words[0]);
        
        for (int i = 0; i < copy.size(); i++) {
            sort(copy[i].begin(), copy[i].end());
        }
        for (int i = 1; i < copy.size(); i++) {
            if (copy[i] != copy[i - 1])
                res.push_back(words[i]);
        }
 
        return res;      
    }
};
```





## 2274. Maximum Consecutive Floors Without Special Floors

[My Submissions](https://leetcode.com/contest/weekly-contest-293/problems/maximum-consecutive-floors-without-special-floors/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-293/)

- **Difficulty:****Medium**

Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.

You are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.

Return *the **maximum** number of consecutive floors without a special floor*.

 

**Example 1:**

```
Input: bottom = 2, top = 9, special = [4,6]
Output: 3
Explanation: The following are the ranges (inclusive) of consecutive floors without a special floor:
- (2, 3) with a total amount of 2 floors.
- (5, 5) with a total amount of 1 floor.
- (7, 9) with a total amount of 3 floors.
Therefore, we return the maximum number which is 3 floors.
```

**Example 2:**

```
Input: bottom = 6, top = 8, special = [7,6,8]
Output: 0
Explanation: Every floor rented is a special floor, so we return 0.
```

 

**Constraints:**

- `1 <= special.length <= 105`
- `1 <= bottom <= special[i] <= top <= 109`
- All the values of `special` are **unique**.



### My C++ solution

```c++
class Solution {
public:
    int maxConsecutive(int bottom, int top, vector<int>& special) {
        
        int res = 0;
        
        sort(special.begin(), special.end());
        
        for (int i = 0; i < special.size() - 1; i++) {
            res = max(res, special[i + 1] - special[i] - 1);
        }
        
        res = max(res, special[0] - bottom);
        res = max(res, top - special[special.size() - 1]);
        
        return res;
    }
};
```





### 2275. Largest Combination With Bitwise AND Greater Than Zero

[My Submissions](https://leetcode.com/contest/weekly-contest-293/problems/largest-combination-with-bitwise-and-greater-than-zero/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-293/)

位运算

- **Difficulty:****Medium**

The **bitwise AND** of an array `nums` is the bitwise AND of all integers in `nums`.

- For example, for `nums = [1, 5, 3]`, the bitwise AND is equal to `1 & 5 & 3 = 1`.
- Also, for `nums = [7]`, the bitwise AND is `7`.

You are given an array of positive integers `candidates`. Evaluate the **bitwise AND** of every **combination** of numbers of `candidates`. Each number in `candidates` may only be used **once** in each combination.

Return *the size of the **largest** combination of* `candidates` *with a bitwise AND **greater** than* `0`.

 

**Example 1:**

```
Input: candidates = [16,17,71,62,12,24,14]
Output: 4
Explanation: The combination [16,17,62,24] has a bitwise AND of 16 & 17 & 62 & 24 = 16 > 0.
The size of the combination is 4.
It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.
Note that more than one combination may have the largest size.
For example, the combination [62,12,24,14] has a bitwise AND of 62 & 12 & 24 & 14 = 8 > 0.
```

**Example 2:**

```
Input: candidates = [8,8]
Output: 2
Explanation: The largest combination [8,8] has a bitwise AND of 8 & 8 = 8 > 0.
The size of the combination is 2, so we return 2.
```

 

**Constraints:**

- `1 <= candidates.length <= 105`
- `1 <= candidates[i] <= 107`

### C++ solution

https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/discuss/2039903/JavaC%2B%2BPython-Bit-Solution

If the bitwise AND of candidates is positive, there is at least one bit that all candidates is 1.

So we can enumerate each bit of 32 bits, the number of candidates that have this bit.
If `a & bit > 0`, it means candidate `a` has this bit

寻找每一位出现 1 的次数的总和

```c++
	int largestCombination(vector<int>& A) {
        int res = 0, cur = 0;
        for (int i = 1; i <= 10000000; i <<= 1) {
            cur = 0;
            for (int& a : A)
                if (a & i)
                    cur++;
            res = max(res, cur);
        }
        return res;        
    }
```



```c++
int largestCombination(vector<int>& A) {
        int res = 0, cur = 0;
        for (int i = 0; i < 24; ++i, cur = 0)
            for (int a: A)
                res = max(res, cur += ((a >> i) & 1));
        return res;    
    }
```

2^24 > 10^7







# Weekly Contest 294

## 2278. Percentage of Letter in String

[My Submissions](https://leetcode.com/contest/weekly-contest-294/problems/percentage-of-letter-in-string/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-294/)

Too easy



### 2279. Maximum Bags With Full Capacity of Rocks

[My Submissions](https://leetcode.com/contest/weekly-contest-294/problems/maximum-bags-with-full-capacity-of-rocks/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-294/)

Easy, but something corner to pay attention to

# Weekly Contest 295

### 2287. Rearrange Characters to Make Target String

[My Submissions](https://leetcode.com/contest/weekly-contest-295/problems/rearrange-characters-to-make-target-string/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-295/)

- **User Accepted:**9427
- **User Tried:**10654
- **Total Accepted:**9592
- **Total Submissions:**17799
- **Difficulty:****Easy**

You are given two **0-indexed** strings `s` and `target`. You can take some letters from `s` and rearrange them to form new strings.

Return *the **maximum** number of copies of* `target` *that can be formed by taking letters from* `s` *and rearranging them.*

 

**Example 1:**

```
Input: s = "ilovecodingonleetcode", target = "code"
Output: 2
Explanation:
For the first copy of "code", take the letters at indices 4, 5, 6, and 7.
For the second copy of "code", take the letters at indices 17, 18, 19, and 20.
The strings that are formed are "ecod" and "code" which can both be rearranged into "code".
We can make at most two copies of "code", so we return 2.
```

**Example 2:**

```
Input: s = "abcba", target = "abc"
Output: 1
Explanation:
We can make one copy of "abc" by taking the letters at indices 0, 1, and 2.
We can make at most one copy of "abc", so we return 1.
Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of "abc".
```

**Example 3:**

```
Input: s = "abbaccaddaeea", target = "aaaaa"
Output: 1
Explanation:
We can make one copy of "aaaaa" by taking the letters at indices 0, 3, 6, 9, and 12.
We can make at most one copy of "aaaaa", so we return 1.
```

 

**Constraints:**

- `1 <= s.length <= 100`
- `1 <= target.length <= 10`
- `s` and `target` consist of lowercase English letters.



My C++	

submit 多次， 有情况没分析全, 如

"abc" "abcd"

```c++
class Solution {
public:
    int rearrangeCharacters(string s, string target) {
        map<char, int> map_target;
        map<char, int> map_s;
        int res = 100;
        
        for (int i = 0; i < strlen(target.c_str()); i++) {
            int count = 1;
            if (map_target.find(target[i]) != map_target.end()) {
                count += map_target.find(target[i])->second;
                map_target.erase(target[i]);
            }
            
            map_target.insert(pair<char, int>(target[i], count));
        }
        
        for (int i = 0; i < strlen(s.c_str()); i++) {
            int count = 1;
            if (map_s.find(s[i]) != map_s.end()) {
                count += map_s.find(s[i])->second;
                map_s.erase(s[i]);
            }
            
            map_s.insert(pair<char, int>(s[i], count));
        }
        
        for (auto iter = map_target.begin(); iter != map_target.end(); iter++) {
            if (map_s.find(iter->first) == map_s.end())
                res = 0;
            if (map_s.find(iter->first) != map_s.end()) {
                if (map_s.find(iter->first)->second / iter->second < res)
                    res = map_s.find(iter->first)->second / iter->second;
                
            }
                
        }
        
        return res;
    }
};
```





### 2288. Apply Discount to Prices

[My Submissions](https://leetcode.com/contest/weekly-contest-295/problems/apply-discount-to-prices/submissions/)[Back to Contest](https://leetcode.com/contest/weekly-contest-295/)

- **User Accepted:**5167
- **User Tried:**7336
- **Total Accepted:**5268
- **Total Submissions:**24275
- **Difficulty:****Medium**       难

A **sentence** is a string of single-space separated words where each word can contain digits, lowercase letters, and the dollar sign `'$'`. A word represents a **price** if it is a non-negative real number preceded by a dollar sign.

- For example, `"$100"`, `"$23"`, and `"$6.75"` represent prices while `"100"`, `"$"`, and `"2$3"` do not.

You are given a string `sentence` representing a sentence and an integer `discount`. For each word representing a price, apply a discount of `discount%` on the price and **update** the word in the sentence. All updated prices should be represented with **exactly two** decimal places.

Return *a string representing the modified sentence*.

 

**Example 1:**

```
Input: sentence = "there are $1 $2 and 5$ candies in the shop", discount = 50
Output: "there are $0.50 $1.00 and 5$ candies in the shop"
Explanation: 
The words which represent prices are "$1" and "$2". 
- A 50% discount on "$1" yields "$0.50", so "$1" is replaced by "$0.50".
- A 50% discount on "$2" yields "$1". Since we need to have exactly 2 decimal places after a price, we replace "$2" with "$1.00".
```

**Example 2:**

```
Input: sentence = "1 2 $3 4 $5 $6 7 8$ $9 $10$", discount = 100
Output: "1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$"
Explanation: 
Applying a 100% discount on any price will result in 0.
The words representing prices are "$3", "$5", "$6", and "$9".
Each of them is replaced by "$0.00".
```

 

**Constraints:**

- `1 <= sentence.length <= 105`
- `sentence` consists of lowercase English letters, digits, `' '`, and `'$'`.
- `sentence` does not have leading or trailing spaces.
- All words in `sentence` are separated by a single space.
- All prices will be **positive** integers without leading zeros.
- All prices will have **at most** `10` digits.
- `0 <= discount <= 100`



My C++ 	Time Limit Exceeded

```c++
class Solution {
public:
    string discountPrices(string sentence, int discount) {
        string res = "";
        string num = "";
        bool is$ = false;
        
        for (int i = 0; i < strlen(sentence.c_str()); i++) {
            if (!is$) { // not after $
                if (sentence[i] == '$')
                    if (i > 0 && sentence[i - 1] == ' ' || i == 0)
                        is$ = true;
                res.append(1, sentence[i]);
            } else {    // after $
                if (sentence[i] >= '0' && sentence[i] <= '9' || sentence[i] == '.' && num != "") {   // is digit
                    num.append(1, sentence[i]);
                    if (i == strlen(sentence.c_str()) - 1) {
                        double val = stod(num);
                        //cout << val;
                        val = val * ((double)(100 - discount)/(double)(100));      //!!!!!!!!!!!!!!!!!!!!!
                        //cout << sentence[i] << val << endl;
                        stringstream ss;
                        ss << fixed << setprecision(2) << val;
                        res.append(ss.str());
                    }
                } else if (sentence[i] == ' '){    // not digit

                    is$ = false;
                    
                    if (num != "") {    // has num
                        double val = stod(num);
                        //cout << val;
                        val = val * ((double)(100 - discount)/(double)(100));      //!!!!!!!!!!!!!!!!!!!!!
                        //cout << sentence[i] << val << endl;
                        stringstream ss;
                        ss << fixed << setprecision(2) << val;
                        res.append(ss.str());
                        
                        num = "";
                        
                    } else {    // no num, num == ""
                        
                    }
                    
                    res.append(1, sentence[i]);
                } else {
                    is$ = false;
                    res.append(num);
                    res.append(1, sentence[i]);
                    num = "";
                }
            }
        }
        
        return res;
    }
};
```





C++ Solution

https://leetcode.com/problems/apply-discount-to-prices/discuss/2085680/C%2B%2B-TIME-WASTE-PROBLEM

```c++

```





# Weekly Contest 296



- [Min Max Game](https://leetcode.com/contest/weekly-contest-296/problems/min-max-game)**3**
- [Partition Array Such That Maximum Difference Is K](https://leetcode.com/contest/weekly-contest-296/problems/partition-array-such-that-maximum-difference-is-k)**4**
- [Replace Elements in an Array](https://leetcode.com/contest/weekly-contest-296/problems/replace-elements-in-an-array)





## 2296. Design a Text Editor

Hard

157151Add to ListShare

Design a text editor with a cursor that can do the following:

- **Add** text to where the cursor is.
- **Delete** text from where the cursor is (simulating the backspace key).
- **Move** the cursor either left or right.

When deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that `0 <= cursor.position <= currentText.length` always holds.

Implement the `TextEditor` class:

- `TextEditor()` Initializes the object with empty text.
- `void addText(string text)` Appends `text` to where the cursor is. The cursor ends to the right of `text`.
- `int deleteText(int k)` Deletes `k` characters to the left of the cursor. Returns the number of characters actually deleted.
- `string cursorLeft(int k)` Moves the cursor to the left `k` times. Returns the last `min(10, len)` characters to the left of the cursor, where `len` is the number of characters to the left of the cursor.
- `string cursorRight(int k)` Moves the cursor to the right `k` times. Returns the last `min(10, len)` characters to the left of the cursor, where `len` is the number of characters to the left of the cursor.

 

**Example 1:**

```
Input
["TextEditor", "addText", "deleteText", "addText", "cursorRight", "cursorLeft", "deleteText", "cursorLeft", "cursorRight"]
[[], ["leetcode"], [4], ["practice"], [3], [8], [10], [2], [6]]
Output
[null, null, 4, null, "etpractice", "leet", 4, "", "practi"]

Explanation
TextEditor textEditor = new TextEditor(); // The current text is "|". (The '|' character represents the cursor)
textEditor.addText("leetcode"); // The current text is "leetcode|".
textEditor.deleteText(4); // return 4
                          // The current text is "leet|". 
                          // 4 characters were deleted.
textEditor.addText("practice"); // The current text is "leetpractice|". 
textEditor.cursorRight(3); // return "etpractice"
                           // The current text is "leetpractice|". 
                           // The cursor cannot be moved beyond the actual text and thus did not move.
                           // "etpractice" is the last 10 characters to the left of the cursor.
textEditor.cursorLeft(8); // return "leet"
                          // The current text is "leet|practice".
                          // "leet" is the last min(10, 4) = 4 characters to the left of the cursor.
textEditor.deleteText(10); // return 4
                           // The current text is "|practice".
                           // Only 4 characters were deleted.
textEditor.cursorLeft(2); // return ""
                          // The current text is "|practice".
                          // The cursor cannot be moved beyond the actual text and thus did not move. 
                          // "" is the last min(10, 0) = 0 characters to the left of the cursor.
textEditor.cursorRight(6); // return "practi"
                           // The current text is "practi|ce".
                           // "practi" is the last min(10, 6) = 6 characters to the left of the cursor.
```

 

**Constraints:**

- `1 <= text.length, k <= 40`
- `text` consists of lowercase English letters.
- At most `2 * 104` calls **in total** will be made to `addText`, `deleteText`, `cursorLeft` and `cursorRight`.







### My C++	Time Limit Exceed		String  erase( )  insert( )

[ Time Limit Exceeded](https://leetcode.com/submissions/detail/715121737/)

```c++

```



### C++  Two Stack

https://leetcode.com/problems/design-a-text-editor/discuss/2111861/Using-Two-Stacks-or-C%2B%2B

[Accepted](https://leetcode.com/submissions/detail/715363409/)



### C++ Two String

https://leetcode.com/problems/design-a-text-editor/discuss/2112623/Two-Strings





# Biweekly Contest 77

### 2255. Count Prefixes of a Given String

[My Submissions](https://leetcode.com/contest/biweekly-contest-77/problems/count-prefixes-of-a-given-string/submissions/)[Back to Contest](https://leetcode.com/contest/biweekly-contest-77/)

 string.find() 函数易得







### 2256. Minimum Average Difference

[My Submissions](https://leetcode.com/contest/biweekly-contest-77/problems/minimum-average-difference/submissions/)[Back to Contest](https://leetcode.com/contest/biweekly-contest-77/)

- **User Accepted:**5395
- **User Tried:**6686
- **Total Accepted:**5520
- **Total Submissions:**18773
- **Difficulty:****Medium**

You are given a **0-indexed** integer array `nums` of length `n`.

The **average difference** of the index `i` is the **absolute** **difference** between the average of the **first** `i + 1` elements of `nums` and the average of the **last** `n - i - 1` elements. Both averages should be **rounded down** to the nearest integer.

Return *the index with the **minimum average difference***. If there are multiple such indices, return the **smallest** one.

**Note:**

- The **absolute difference** of two numbers is the absolute value of their difference.
- The **average** of `n` elements is the **sum** of the `n` elements divided (**integer division**) by `n`.
- The average of `0` elements is considered to be `0`.

 

**Example 1:**

```
Input: nums = [2,5,3,9,5,3]
Output: 3
Explanation:
- The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.
- The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.
- The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.
- The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.
- The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.
- The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.
The average difference of index 3 is the minimum average difference so return 3.
```

**Example 2:**

```
Input: nums = [0]
Output: 0
Explanation:
The only index is 0 so return 0.
The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 105`





My C++ solution 

```C++
class Solution {
public:
    int minimumAverageDifference(vector<int>& nums) {
        if (nums.size() == 1)
            return 0;
        
        long sum = 0;
        long sum_cur = 0;
        long min_dif_val = 0;
        long min_dif_index = 0;
        
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        
        
        // i = 0
        sum_cur += nums[0];
        min_dif_val = abs((int) (sum_cur / 1 - (sum - sum_cur) / (nums.size() - 1)));
        
        
        for (int i = 1; i < nums.size() - 1; i++) {
            sum_cur += nums[i];
            
            long dif_val = abs((int) (sum_cur / (i + 1) - (sum - sum_cur) / (nums.size() - 1 - i)));
            
            if (dif_val < min_dif_val) {
                min_dif_val = dif_val;
                min_dif_index = i;
            }
        }
        
      	//i = nums.size() - 1
        long dif_lastone = sum / nums.size();
        if (dif_lastone < min_dif_val) {
            min_dif_val = dif_lastone;
            min_dif_index = nums.size() - 1; 
        }
        
        return (int)min_dif_index;
    }
};
```

int 会溢出

边界情况注意分母为 0

注意 If there are multiple such indices, return the **smallest** one.  面试时遇到答案不唯一时需指出

abs 内需指定类型，否则会产生 ambiguous 错误: abs(int)   abs(long)





# Biweekly Contest 78

## 2269. Find the K-Beauty of a Number

[My Submissions](https://leetcode.com/contest/biweekly-contest-78/problems/find-the-k-beauty-of-a-number/submissions/)[Back to Contest](https://leetcode.com/contest/biweekly-contest-78/)

- **User Accepted:**8341
- **User Tried:**9004
- **Total Accepted:**8577
- **Total Submissions:**15816
- **Difficulty:****Easy**

The **k-beauty** of an integer `num` is defined as the number of **substrings** of `num` when it is read as a string that meet the following conditions:

- It has a length of `k`.
- It is a divisor of `num`.

Given integers `num` and `k`, return *the k-beauty of* `num`.

Note:

- **Leading zeros** are allowed.
- `0` is not a divisor of any value.

A **substring** is a contiguous sequence of characters in a string.

 

**Example 1:**

```
Input: num = 240, k = 2
Output: 2
Explanation: The following are the substrings of num of length k:
- "24" from "240": 24 is a divisor of 240.
- "40" from "240": 40 is a divisor of 240.
Therefore, the k-beauty is 2.
```

**Example 2:**

```
Input: num = 430043, k = 2
Output: 2
Explanation: The following are the substrings of num of length k:
- "43" from "430043": 43 is a divisor of 430043.
- "30" from "430043": 30 is not a divisor of 430043.
- "00" from "430043": 0 is not a divisor of 430043.
- "04" from "430043": 4 is not a divisor of 430043.
- "43" from "430043": 43 is a divisor of 430043.
Therefore, the k-beauty is 2.
```

 

**Constraints:**

- `1 <= num <= 109`
- `1 <= k <= num.length` (taking `num` as a string)



### My C++ solution

```c++
class Solution {
public:
    int divisorSubstrings(int num, int k) {
        
        string num_str = to_string(num); 
        int res = 0;
        
        for (int i = k - 1; i < num_str.size(); i++) {
            int start = i - k + 1;
            string sub_str = num_str.substr(start, k);
            int sub_num = atoi(sub_str.c_str());
            if (sub_num != 0 && num % sub_num == 0)
                res++;
        }
        
        return res;
    }
};
```





## 2270. Number of Ways to Split Array

[My Submissions](https://leetcode.com/contest/biweekly-contest-78/problems/number-of-ways-to-split-array/submissions/)[Back to Contest](https://leetcode.com/contest/biweekly-contest-78/)

- **User Accepted:**7437
- **User Tried:**8483
- **Total Accepted:**7559
- **Total Submissions:**20071
- **Difficulty:****Medium**

You are given a **0-indexed** integer array `nums` of length `n`.

`nums` contains a **valid split** at index `i` if the following are true:

- The sum of the first `i + 1` elements is **greater than or equal to** the sum of the last `n - i - 1` elements.
- There is **at least one** element to the right of `i`. That is, `0 <= i < n - 1`.

Return *the number of **valid splits** in* `nums`.

 

**Example 1:**

```
Input: nums = [10,4,-8,7]
Output: 2
Explanation: 
There are three ways of splitting nums into two non-empty parts:
- Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split.
- Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split.
- Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split.
Thus, the number of valid splits in nums is 2.
```

**Example 2:**

```
Input: nums = [2,3,1,0]
Output: 2
Explanation: 
There are two valid splits in nums:
- Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. 
- Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split.
```

 

**Constraints:**

- `2 <= nums.length <= 105`
- `-105 <= nums[i] <= 105`

[Discuss](https://leetcode.com/problems/number-of-ways-to-split-array/discuss)

```c++
class Solution {
public:
    int waysToSplitArray(vector<int>& nums) {
        long cur_sum = 0;
        long sum = 0;
        int res = 0;
        
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }        
        for (int i = 0; i < nums.size() - 1; i++) {
            cur_sum += nums[i];
            if (cur_sum * 2 >= sum)
                res++;
        }
        
        return res;
    }
};
```







## 2271. Maximum White Tiles Covered by a Carpet

[My Submissions](https://leetcode.com/contest/biweekly-contest-78/problems/maximum-white-tiles-covered-by-a-carpet/submissions/)[Back to Contest](https://leetcode.com/contest/biweekly-contest-78/)

- **Difficulty:****Medium**

You are given a 2D integer array `tiles` where `tiles[i] = [li, ri]` represents that every tile `j` in the range `li <= j <= ri` is colored white.

You are also given an integer `carpetLen`, the length of a single carpet that can be placed **anywhere**.

Return *the **maximum** number of white tiles that can be covered by the carpet*.

 

**Example 1:**

![img](images/example1drawio3.png)

```
Input: tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10
Output: 9
Explanation: Place the carpet starting on tile 10. 
It covers 9 white tiles, so we return 9.
Note that there may be other places where the carpet covers 9 white tiles.
It can be shown that the carpet cannot cover more than 9 white tiles.
```

**Example 2:**

![img](images/example2drawio.png)

```
Input: tiles = [[10,11],[1,1]], carpetLen = 2
Output: 2
Explanation: Place the carpet starting on tile 10. 
It covers 2 white tiles, so we return 2.
```

 

**Constraints:**

- `1 <= tiles.length <= 5 * 104`
- `tiles[i].length == 2`
- `1 <= li <= ri <= 109`
- `1 <= carpetLen <= 109`
- The `tiles` are **non-overlapping**.



### C++ solution  --  Sliding Window

https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/discuss/2038534/Sliding-Window

```c++
class Solution {

    
public:
    
    int maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {
        int res = 0;
        int left = 0;
        int cover = 0;
        
        sort(tiles.begin(), tiles.end());
        for (int right = 0; res < carpetLen && right < tiles.size(); ) {
            if (left == right || tiles[left][0] + carpetLen > tiles[right][1]) {
                cover += min(carpetLen, tiles[right][1] - tiles[right][0] + 1);
                res = max(res, cover);
                right++;
            } else {
                int partial = max(0, tiles[left][0] + carpetLen - tiles[right][0]);
                res = max(res, cover + partial);
                
                cover -= (tiles[left][1] - tiles[left][0] + 1);
                left++;
            }
        }
        
        return res;
    }
};
```







# Biweekly Contest 79

### 2283. Check if Number Has Equal Digit Count and Digit Value

[My Submissions](https://leetcode.com/contest/biweekly-contest-79/problems/check-if-number-has-equal-digit-count-and-digit-value/submissions/)[Back to Contest](https://leetcode.com/contest/biweekly-contest-79/)

- **User Accepted:**11341
- **User Tried:**12103
- **Total Accepted:**11665
- **Total Submissions:**16264
- **Difficulty:****Easy**

You are given a **0-indexed** string `num` of length `n` consisting of digits.

Return `true` *if for **every** index* `i` *in the range* `0 <= i < n`*, the digit* `i` *occurs* `num[i]` *times in* `num`*, otherwise return* `false`.

 

**Example 1:**

```
Input: num = "1210"
Output: true
Explanation:
num[0] = '1'. The digit 0 occurs once in num.
num[1] = '2'. The digit 1 occurs twice in num.
num[2] = '1'. The digit 2 occurs once in num.
num[3] = '0'. The digit 3 occurs zero times in num.
The condition holds true for every index in "1210", so return true.
```

**Example 2:**

```
Input: num = "030"
Output: false
Explanation:
num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num.
num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num.
num[2] = '0'. The digit 2 occurs zero times in num.
The indices 0 and 1 both violate the condition, so return false.
```

 

**Constraints:**

- `n == num.length`
- `1 <= n <= 10`
- `num` consists of digits.



My C++ solution

```c++
class Solution {
public:
    bool digitCount(string num) {
        int nums[10] = {0};
        int count[10] = {0};
        
        for (int i = 0; i < num.length(); i++) {
            nums[i] = num[i] - '0';
            
        }
        
        for (int i = 0; i < num.length(); i++) {
            if (nums[i] >= 0 && nums[i] < num.length())
                count[nums[i]]++;
        }
        
        for (int i = 0; i < num.length(); i++) {
            cout << nums[i] << endl;
            if (nums[i] != count[i]) 
                return false;
        }
        
        return true;
    }
};
```



### 2284. Sender With Largest Word Count

[My Submissions](https://leetcode.com/contest/biweekly-contest-79/problems/sender-with-largest-word-count/submissions/)[Back to Contest](https://leetcode.com/contest/biweekly-contest-79/)

- **User Accepted:**9274
- **User Tried:**10322
- **Total Accepted:**9493
- **Total Submissions:**18938
- **Difficulty:****Medium**

You have a chat log of `n` messages. You are given two string arrays `messages` and `senders` where `messages[i]` is a **message** sent by `senders[i]`.

A **message** is list of **words** that are separated by a single space with no leading or trailing spaces. The **word count** of a sender is the total number of **words** sent by the sender. Note that a sender may send more than one message.

Return *the sender with the **largest** word count*. If there is more than one sender with the largest word count, return *the one with the **lexicographically largest** name*.

**Note:**

- Uppercase letters come before lowercase letters in lexicographical order.
- `"Alice"` and `"alice"` are distinct.

 

**Example 1:**

```
Input: messages = ["Hello userTwooo","Hi userThree","Wonderful day Alice","Nice day userThree"], senders = ["Alice","userTwo","userThree","Alice"]
Output: "Alice"
Explanation: Alice sends a total of 2 + 3 = 5 words.
userTwo sends a total of 2 words.
userThree sends a total of 3 words.
Since Alice has the largest word count, we return "Alice".
```

**Example 2:**

```
Input: messages = ["How is leetcode for everyone","Leetcode is useful for practice"], senders = ["Bob","Charlie"]
Output: "Charlie"
Explanation: Bob sends a total of 5 words.
Charlie sends a total of 5 words.
Since there is a tie for the largest word count, we return the sender with the lexicographically larger name, Charlie.
```

 

**Constraints:**

- `n == messages.length == senders.length`
- `1 <= n <= 104`
- `1 <= messages[i].length <= 100`
- `1 <= senders[i].length <= 10`
- `messages[i]` consists of uppercase and lowercase English letters and `' '`.
- All the words in `messages[i]` are separated by **a single space**.
- `messages[i]` does not have leading or trailing spaces.
- `senders[i]` consists of uppercase and lowercase English letters only.



My C++ solution

```c++
class Solution {
public:
    string largestWordCount(vector<string>& messages, vector<string>& senders) {
        map<string, int> map_count;
        int max_count = 0;
        string res;
        
        for (int i = 0; i < senders.size(); i++) {
            int count = countWords(messages[i]);
            if (map_count.find(senders[i]) != map_count.end())
                count += map_count.find(senders[i])->second;
            map_count.erase(senders[i]);
            map_count.insert(pair<string, int>(senders[i], count));
        }
        
        
        for (auto iter = map_count.begin(); iter != map_count.end(); iter++) {
            if (iter->second > max_count) {
                max_count = iter->second;
                res = iter->first;
            }
            
            if (iter->second == max_count && iter->first > res) {
                res = iter->first;
            }
        }
        
        return res;
    }
    
    
    int countWords(string s) {
        int count = 1;
        for (int i = 0; i < strlen(s.c_str()); i++) {
            if (s[i] == ' ')
                count++;
        }
        
        cout << count << endl;
        return count;
    }
};
```

